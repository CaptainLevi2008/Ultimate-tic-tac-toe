<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tic-Tac-Toe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
        }
        .main-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            background-color: #1f2937; /* gray-800 */
            padding: 6px;
            max-width: 600px;
            width: 95vw;
            aspect-ratio: 1 / 1;
            margin: auto;
            border-radius: 8px;
        }
        .local-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            background-color: #6b7280; /* gray-500 */
            position: relative;
            transition: all 0.2s ease-in-out;
        }
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f9fafb; /* gray-50 */
            aspect-ratio: 1 / 1;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .cell:hover:not(.x):not(.o) {
            background-color: #dbeafe; /* blue-100 */
        }
        .local-board.active {
            background-color: #60a5fa; /* blue-400 */
            box-shadow: 0 0 20px rgba(96, 165, 250, 0.8);
        }
        .local-board.won-x, .local-board.won-o, .local-board.tie {
            pointer-events: none;
            background-color: #374151; /* gray-700 */
        }
        /* Style for cells inside a completed board */
        .local-board.won-x .cell,
        .local-board.won-o .cell,
        .local-board.tie .cell {
            cursor: not-allowed;
        }
        .winner-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            pointer-events: none; /* Allows clicks to go through if needed, though board is disabled */
        }
        .winner-overlay svg {
            width: 100%;
            height: 100%;
        }
        .winner-overlay-x {
            color: rgba(59, 130, 246, 0.6);
        }
        .winner-overlay-o {
            color: rgba(239, 68, 68, 0.6);
        }
        .winner-overlay-tie {
             color: rgba(107, 114, 128, 0.6);
        }

        .x svg { stroke: #2563eb; } /* blue-600 */
        .o svg { stroke: #dc2626; } /* red-600 */

        /* Responsive font size for the winner overlay */
        @media (min-width: 640px) {
            .winner-overlay {
                font-size: 6rem; /* 96px */
            }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="min-h-screen flex flex-col items-center justify-center p-4">
        <div class="text-center mb-4">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">Ultimate Tic-Tac-Toe</h1>
            <p class="text-gray-600 mt-2">Win 3 small boards in a row to win the game!</p>
        </div>

        <div id="game-status" class="h-10 text-xl font-semibold mb-4 text-center"></div>

        <div class="main-board" id="main-board">
            <!-- Game boards will be generated by JavaScript -->
        </div>

        <button id="restart-button" class="mt-8 px-8 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-transform transform hover:scale-105">
            Start New Game
        </button>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const mainBoardElement = document.getElementById('main-board');
        const statusElement = document.getElementById('game-status');
        const restartButton = document.getElementById('restart-button');

        const PLAYER = 'X';
        const COMPUTER = 'O';
        const TIE = 'T';

        let localBoardsState, mainBoardState, currentPlayer, nextLocalBoardIndex, gameOver;

        function initializeGame() {
            localBoardsState = Array(9).fill(null).map(() => Array(9).fill(null));
            mainBoardState = Array(9).fill(null);
            currentPlayer = PLAYER;
            nextLocalBoardIndex = null; // null means any board is playable
            gameOver = false;

            mainBoardElement.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const localBoard = document.createElement('div');
                localBoard.className = 'local-board';
                localBoard.dataset.boardIndex = i;

                for (let j = 0; j < 9; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.boardIndex = i;
                    cell.dataset.cellIndex = j;
                    cell.addEventListener('click', handleCellClick);
                    localBoard.appendChild(cell);
                }
                mainBoardElement.appendChild(localBoard);
            }

            updateStatus("Your turn (X). Play anywhere!");
            updateActiveBoards();
        }

        function handleCellClick(event) {
            if (gameOver || currentPlayer !== PLAYER) return;

            const cell = event.target.closest('.cell');
            if (!cell) return;

            const boardIndex = parseInt(cell.dataset.boardIndex);
            const cellIndex = parseInt(cell.dataset.cellIndex);

            const isBoardWon = mainBoardState[boardIndex] !== null;
            const isCellTaken = localBoardsState[boardIndex][cellIndex] !== null;
            const isValidBoard = nextLocalBoardIndex === null || nextLocalBoardIndex === boardIndex;

            if (isBoardWon || isCellTaken || !isValidBoard) {
                return;
            }

            makeMove(boardIndex, cellIndex, PLAYER);

            if (!gameOver) {
                triggerComputerTurn();
            }
        }

        function triggerComputerTurn() {
            currentPlayer = COMPUTER;
            updateStatus("Computer's turn (O)...");
            mainBoardElement.style.pointerEvents = 'none';

            setTimeout(() => {
                computerMove();
                if (!gameOver) {
                    currentPlayer = PLAYER;
                    if (nextLocalBoardIndex === null) {
                        updateStatus("Your turn (X). Play on any active board.");
                    } else {
                        updateStatus(`Your turn (X). Play in the highlighted board.`);
                    }
                }
                mainBoardElement.style.pointerEvents = 'auto';
            }, 800);
        }

        function computerMove() {
            if (gameOver) return;

            let availableMoves = [];
            if (nextLocalBoardIndex !== null && mainBoardState[nextLocalBoardIndex] === null) {
                for (let i = 0; i < 9; i++) {
                    if (localBoardsState[nextLocalBoardIndex][i] === null) {
                        availableMoves.push({ boardIndex: nextLocalBoardIndex, cellIndex: i });
                    }
                }
            } else {
                 for (let i = 0; i < 9; i++) {
                    if (mainBoardState[i] === null) {
                        for (let j = 0; j < 9; j++) {
                            if (localBoardsState[i][j] === null) {
                                availableMoves.push({ boardIndex: i, cellIndex: j });
                            }
                        }
                    }
                }
            }

            if (availableMoves.length === 0) return;

            let bestMove = null;
            for (const move of availableMoves) {
                if (isLocalWinningMove(move.boardIndex, move.cellIndex, COMPUTER)) {
                    bestMove = move;
                    break;
                }
            }
            if (!bestMove) {
                for (const move of availableMoves) {
                    if (isLocalWinningMove(move.boardIndex, move.cellIndex, PLAYER)) {
                        bestMove = move;
                        break;
                    }
                }
            }
            if (!bestMove) {
                bestMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
            }

            makeMove(bestMove.boardIndex, bestMove.cellIndex, COMPUTER);
        }

        function makeMove(boardIndex, cellIndex, player) {
            localBoardsState[boardIndex][cellIndex] = player;

            const cell = document.querySelector(`.cell[data-board-index='${boardIndex}'][data-cell-index='${cellIndex}']`);
            cell.classList.add(player.toLowerCase());
            cell.innerHTML = getPlayerSVG(player);

            const localBoardWon = checkWinner(localBoardsState[boardIndex], player);
            if (localBoardWon) {
                mainBoardState[boardIndex] = player;
                markLocalBoardAsWon(boardIndex, player);

                const globalWinner = checkWinner(mainBoardState, player);
                if (globalWinner) {
                    endGame(player);
                    return;
                }
            } else if (localBoardsState[boardIndex].every(c => c !== null)) {
                mainBoardState[boardIndex] = TIE;
                markLocalBoardAsTie(boardIndex);
            }

            if (mainBoardState.every(s => s !== null)) {
                endGame(TIE);
                return;
            }

            nextLocalBoardIndex = mainBoardState[cellIndex] !== null ? null : cellIndex;

            if (!gameOver) {
                updateActiveBoards();
            }
        }

        function checkWinner(board, player) {
            const winConditions = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            return winConditions.some(condition => condition.every(index => board[index] === player));
        }

        function isLocalWinningMove(boardIndex, cellIndex, player) {
            const tempBoard = [...localBoardsState[boardIndex]];
            tempBoard[cellIndex] = player;
            return checkWinner(tempBoard, player);
        }

        function endGame(winner) {
            gameOver = true;
            document.querySelectorAll('.local-board').forEach(b => b.classList.remove('active'));

            if (winner === TIE) {
                updateStatus("It's a tie game!");
            } else if (winner === PLAYER) {
                updateStatus("Congratulations! You win! 🎉");
            } else {
                updateStatus("Computer wins! Better luck next time.");
            }
        }

        function updateStatus(message) {
            statusElement.textContent = message;
        }

        function updateActiveBoards() {
            document.querySelectorAll('.local-board').forEach((board, index) => {
                board.classList.remove('active');
                if (mainBoardState[index] === null) {
                    if (nextLocalBoardIndex === null || nextLocalBoardIndex === index) {
                        board.classList.add('active');
                    }
                }
            });
        }

        function markLocalBoardAsWon(boardIndex, player) {
            const boardElement = document.querySelector(`.local-board[data-board-index='${boardIndex}']`);
            boardElement.classList.add(`won-${player.toLowerCase()}`);
            const overlay = document.createElement('div');
            overlay.className = `winner-overlay winner-overlay-${player.toLowerCase()}`;
            overlay.innerHTML = getWinnerOverlaySVG(player);
            boardElement.appendChild(overlay);
        }

        function markLocalBoardAsTie(boardIndex) {
            const boardElement = document.querySelector(`.local-board[data-board-index='${boardIndex}']`);
            boardElement.classList.add('tie');
            const overlay = document.createElement('div');
            overlay.className = 'winner-overlay winner-overlay-tie';
            overlay.textContent = '–';
            boardElement.appendChild(overlay);
        }

        function getWinnerOverlaySVG(player) {
            if (player === 'X') {
                return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
            }
            if (player === 'O') {
                return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg>`;
            }
            return '';
        }

        function getPlayerSVG(player) {
            const iconSize = 'w-full h-full p-1';
            if (player === 'X') {
                return `<svg class="${iconSize}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
            }
            if (player === 'O') {
                return `<svg class="${iconSize}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle></svg>`;
            }
            return '';
        }

        restartButton.addEventListener('click', initializeGame);
        initializeGame();
    });
    </script>
</body>
</html>